const { OpenAI } = require('openai');
const vscode = require('vscode');
const TemporaryFile = require('../temporary-file/create-temporary');
const UnitTestManager = require('../auto-test/unit-test-manager');
const WorkspaceChecker = require('../../../utils/check-workspace');

class GenerateTestModule {
    constructor() {
        this.temporary = new TemporaryFile();
        this.unitTest = new UnitTestManager();
    }
    async generateUnitTest({ code, type = "controller", resource = null, request = null, attributeMigration = null, modelName = null, attributesModelDart = null, framework = null }) {
        const openai = new OpenAI({
            apiKey: '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',
        });

        let prompt = '';

        switch (framework) {
            case 'laravel':
                switch (type) {
                    case 'function':

                        prompt = `
You are a professional SOFTWARE TESTER.
Your task is to create a simple unit test code using Mockery, designed to be understandable and executable by beginner programmers.

Objective
Write unit test code for the following controller function snippet:
${code}

${attributeMigration ? `The model ${modelName} contains the following attributes: ${attributeMigration}` : ''}
                            
RULES & FORMAT:
1. The test class name must be: TemporaryTest
2. All tests must use Mockery
3. Each test should be written as a public function with the format: public function test_*()
4. Do not include comments or explanations — only the full PHP test code
5. No additional output besides the code itself

REQUIRED TEST COVERAGE (minimum of 4 tests if possible):
1. Successful test
2. Failure test
3. Validation error or exception test
4. Test with missing or no parameters

ADDITIONAL GUIDELINES:
1. Use full mocking (Mockery) for all external dependencies (such as Auth, View, Redirect, Request, etc.)
2. If the tested code calls any external libraries/helpers, create mock functions for them if they do not already exist, except for Str, Hash, and UUID, where explicit values should be used. For example:
    Code to be tested:
    $validated['short_description'] = Str::of($validated['description'])->limit(100);

    Corresponding test code:
    $validated['short_description'] = "lorem ipsum";

3. Import all necessary dependencies, such as Auth, View, Redirect, Mockery, namespace, and others.
Follow the test pattern and structure shown in the example below.
FILE STRUCTURE
All test code must be written within the following single class file:

<?php
namespace Tests\\Feature;

use Tests\\TestCase;
use Mockery;
use Illuminate\\Support\\Facades\\Auth;
use Illuminate\\Support\\Facades\\Redirect;
use Illuminate\\Support\\Facades\\View;

class TemporaryTest extends TestCase
{
    protected function tearDown(): void
    {
        Mockery::close();
        parent::tearDown();
    }
}

4. The code must follow the structure and style of the following unit test examples

Test: Login is called, returns login view
public function test_login_return_view()
{
    View::shouldReceive('make')
        ->once()
        ->with('auth.login')
        ->andReturn('test_view');

    $controller = new class extends AuthController {
        public function login()
        {
            return View::make('auth.login');
        }
    };

    $response = $controller->login();

    $this->assertEquals('test_view', $response);
}

Test: User is already logged in, redirected to dashboard (login successful)
public function test_login_user_already_logged_in_redirects_to_dashboard()
    {
        // Mock Auth::check() return true
        Auth::shouldReceive('check')
            ->once()
            ->andReturn(true);

        // Mock Redirect::to('dashboard')
        Redirect::shouldReceive('to')
            ->with('dashboard')
            ->andReturn('redirect_dashboard');

        $controller = new class {
            public function login() {
                if (Auth::check()) {
                    return Redirect::to('dashboard');
                } else {
                    return View::make('dashboard.pages.auth.login');
                }
            }
        };

        $result = $controller->login();

        $this->assertEquals('redirect_dashboard', $result);
    }

Test: User is not logged in, returns login view (login failed)
public function test_login_user_not_logged_in_returns_login_view()
{
    // Mock Auth::check() return false
    Auth::shouldReceive('check')
        ->once()
        ->andReturn(false);

    // Mock View::make
    View::shouldReceive('make')
        ->with('dashboard.pages.auth.login')
        ->andReturn('login_view');

    $controller = new class {
        public function login() {
            if (Auth::check()) {
                return Redirect::to('dashboard');
            } else {
                return View::make('dashboard.pages.auth.login');
            }
        }
    };

    $result = $controller->login();

    $this->assertEquals('login_view', $result);
}

Test: login is called without parameters (no parameters)
public function test_login_without_parameters_works_well()
{
    Auth::shouldReceive('check')
        ->once()
        ->andReturn(false);

    View::shouldReceive('make')
        ->with('dashboard.pages.auth.login')
        ->andReturn('login_view');

    $controller = new class {
        public function login() {
            if (Auth::check()) {
                return Redirect::to('dashboard');
            } else {
                return View::make('dashboard.pages.auth.login');
            }
        }
    };

    $result = $controller->login();

    $this->assertEquals('login_view', $result);
}

Note: For any test that interacts with the database, ensure you mock the Eloquent Model using Mockery.
public function test_add_menu_success()
{
    // Fake data request (pakai stdClass, bukan facade Request)
    $mockRequest = new \stdClass();
    $mockRequest->image = new class {
        public function extension()
        {
            return 'jpg';
        }
        public function storeAs($folder, $name, $driver)
        {
            return 'image/123456789.jpg';
        }
    };
    $mockRequest->food_name = 'Nasi Goreng';
    $mockRequest->desc = 'Enak sekali';

    // Eloquent Model create DI-mock
    $foodMock = Mockery::mock();
    $foodMock->shouldReceive('create')->once()->withArgs(function ($input) {
        return $input['url_img'] === 'storage/image/123456789.jpg'
            && $input['food_name'] === 'Nasi Goreng'
            && $input['desc'] === 'Enak sekali'
            && $input['created_at'] instanceof Carbon
            && $input['updated_at'] instanceof Carbon;
    })->andReturnTrue();

    // Mock Redirect
    $mockRedirectResponse = Mockery::mock();
    $mockRedirectResponse->shouldReceive('with')
        ->with('success', 'Menu uploaded successfully.')
        ->andReturn('redirect_success');

    Redirect::shouldReceive('back')->once()->andReturn($mockRedirectResponse);

    $controller = new class($foodMock) {
        protected $food;
        public function __construct($food)
        {
            $this->food = $food;
        }

        public function addMenu($request)
        {
            $imageName = time() . '.' . $request->image->extension();
            $path = $request->image->storeAs('image', $imageName, 'public');

            $this->food->create([
                'url_img' => "storage/{$path}",
                'food_name' => $request->food_name,
                'desc' => $request->desc,
                'created_at' => now(),
                'updated_at' => now()
            ]);

            return Redirect::back()->with('success', 'Menu uploaded successfully.');
        }
    };

    $result = $controller->addMenu($mockRequest);

    $this->assertEquals('redirect_success', $result);
}
5. Use phpunit and import use Tests\\TestCase.
6. Pay attention to the use of the :: operator — it should follow the example below:
    Redirect::shouldReceive('back')->once()->andReturn($mockRedirectResponse);

    Auth::shouldReceive('check')
            ->once()
            ->andReturn(false);

    View::shouldReceive('make')
                ->with('dashboard.pages.auth.login')
                ->andReturn('login_view');

    Untuk mock jangan menggunakan :: tetapi gunakan ->, berikut contohnya:
    $foodMock->shouldReceive('create')->once()->withArgs(function ($input) {
    })->andReturnTrue();

    $mockRedirectResponse->shouldReceive('with')
        ->with('success', 'Menu uploaded successfully.')
        ->andReturn('redirect_success');

ADDITIONAL NOTE
If the tested code uses an external library, create a helper function for it.
Below is an example of a unit test that includes a custom helper.

public function test_authentication_successful_login_redirect_to_dashboard()
{
    if (!function_exists('notify')) {
        function notify()
        {
            return new class {
                public function success($message, $title = null) {}
                public function error($message, $title = null) {}
            };
        }
    }

    $request = Request::create('/login', 'POST', [
        'email' => 'ahmad@gmail.com',
        'password' => 'rahasia'
    ]);

    Auth::shouldReceive('attempt')
        ->once()
        ->with([
            'email' => 'ahmad@gmail.com',
            'password' => 'rahasia'
        ])
        ->andReturn(true);

    Route::get('/dashboard', function () {
        return 'Dashboard';
    })->name('dashboard.index');

    $controller = new AuthController();
    $response = $controller->authenticate($request);

    $this->assertInstanceOf(RedirectResponse::class, $response);
    $this->assertTrue($response->isRedirect(route('dashboard.index')));
}
`;
                        break;
                    case "api function":
                        prompt = `
You are a professional SOFTWARE TESTER.
Your task is to create a simple unit test code using Mockery, designed to be understandable and executable by beginner programmers.

Objective
Write unit test code for the following controller function snippet:
${code}

${request ? `This code requires the following attributes to run properly: ${request}` : ''}

${resource ? `This code expects the following attributes in the result: ${resource}` : ''}
                            
RULES & FORMAT:
1. The test class name must be: TemporaryTest
2. All tests must use Mockery
3. Each test should be written as a public function with the format: public function test_*()
4. Do not include comments or explanations — only the full PHP test code
5. No additional output besides the code itself

REQUIRED TEST COVERAGE (minimum of 4 tests if possible):
1. Successful test
2. Failure test
3. Validation error or exception test
4. Test with missing or no parameters

ADDITIONAL GUIDELINES:
1. Use full mocking (Mockery) for all external dependencies (such as Auth, View, Redirect, Request, etc.)
2. If the tested code calls any external libraries/helpers, create mock functions for them if they do not already exist, except for Str, Hash, and UUID, where explicit values should be used. For example:
    Code to be tested:
    $validated['short_description'] = Str::of($validated['description'])->limit(100);

    Corresponding test code:
    $validated['short_description'] = "lorem ipsum";

3. Import all necessary dependencies, such as Auth, View, Redirect, Mockery, namespace, and others.
Follow the test pattern and structure shown in the example below.
FILE STRUCTURE
All test code must be written within the following single class file:

<?php
namespace Tests\\Feature;

use App\\Http\\Requests\\Auth\\LoginRequest;
use App\\Http\\Resources\\UserResource;
use Illuminate\\Foundation\\Testing\\WithFaker;
use Illuminate\\Http\\Exceptions\\HttpResponseException;
use Illuminate\\Support\\acades\\Hash;
use Mockery;
use Tests\\TestCase;

class TemporaryTest extends TestCase
{
    use WithFaker;

    protected function tearDown(): void
    {
        Mockery::close();
        parent::tearDown();
    }
}

4. The code must follow the structure and style of the following unit test examples

Test: User is already logged in, redirected to dashboard (login successful)
public function test_login_success()
{
    $mockRequest = Mockery::mock(LoginRequest::class);
    $mockRequest->shouldReceive('validate')->once()->andReturn([
        'email' => 'user@gmail.com',
        'password' => 'rahasia',
    ]);

    $userMock = Mockery::mock();
    $userMock->id = 1;
    $userMock->email = 'user@gmail.com';
    $userMock->password = bcrypt('rahasia');
    $userMock->token = null;
    $userMock->shouldReceive('save')->once();

    Hash::shouldReceive('check')
        ->once()
        ->with('rahasia', $userMock->password)
        ->andReturn(true);

    $userQueryBuilderMock = Mockery::mock();
    $userQueryBuilderMock->shouldReceive('first')
        ->once()
        ->andReturn($userMock);

    $userModelMock = Mockery::mock();
    $userModelMock->shouldReceive('where')
        ->once()
        ->with('email', 'user@gmail.com')
        ->andReturn($userQueryBuilderMock);

    $userResourceMock = Mockery::mock(UserResource::class, [$userMock])->makePartial();
    $this->instance(UserResource::class, $userResourceMock);

    $controller = new class($userModelMock) {
        protected $user;
        public function __construct($user)
        {
            $this->user = $user;
        }
        public function login($request)
        {
            $data = $request->validate([
                'email' => ['required', 'email'],
                'password' => ['required', 'string'],
            ]);
            $user = $this->user->where('email', $data['email'])->first();
            if (!$user || !Hash::check($data['password'], $user->password)) {
                throw new HttpResponseException(response([
                    "status" => false,
                    "errors" => [
                        "message" => [
                            "email or password wrong"
                        ]
                    ]
                ], 401));
            }
            $user->token = 'fake-uuid-1234';
            $user->save();
            return new UserResource($user);
        }
    };

    $result = $controller->login($mockRequest);

    $this->assertInstanceOf(UserResource::class, $result);
}

Test: fetch data from ClassRoom model and return as JSON response (successful)
public function test_get_classrooms_success()
{
    // Mock data which will be returned by the ClassRoom model
    $mockClassrooms = collect([
        (object)['id' => 1, 'name' => 'Kelas A'],
        (object)['id' => 2, 'name' => 'Kelas B'],
    ]);

    // Mock ClassRoom model and method all()
    $classRoomModelMock = Mockery::mock();
    $classRoomModelMock->shouldReceive('all')->once()->andReturn($mockClassrooms);

    // Mock ClassRoomResource::collection()
    $mockResourceCollection = ['formatted_classroom_data'];
    $classRoomResourceMock = Mockery::mock('alias:' . \App\Http\Resources\ClassRoomResource::class);
    $classRoomResourceMock->shouldReceive('collection')
        ->once()
        ->with($mockClassrooms)
        ->andReturn($mockResourceCollection);

    // Controller with dependency injection of ClassRoom model
    $controller = new class($classRoomModelMock) {
        protected $classRoom;

        public function __construct($classRoom)
        {
            $this->classRoom = $classRoom;
        }

        public function get(Request $request)
        {
            $classRooms = $this->classRoom->all();

            return response()->json([
                'data' => \\App\\Http\\Resources\\ClassRoomResource::collection($classRooms)
            ], 200);
        }
    };

    // running the controller method
    $mockRequest = Mockery::mock(Request::class);
    $response = $controller->get($mockRequest);

    // Assert response
    $this->assertInstanceOf(\\Illuminate\\Http\\JsonResponse::class, $response);
    $this->assertEquals(200, $response->getStatusCode());

    $responseData = $response->getData(true);
    $this->assertEquals(['formatted_classroom_data'], $responseData['data']);
}

Test: Show a specific classroom by ID and return as JSON response (successful)
public function test_show_classroom_success()
{
    $mockId = 1;

    // Mock data classroom which will be returned (usually Eloquent Model)
    $mockClassroom = (object)[
        'id' => $mockId,
        'name' => 'Kelas A',
    ];

    // Mock query builder for ClassRoom::where() -> first()
    $queryBuilderMock = Mockery::mock();
    $queryBuilderMock->shouldReceive('first')->once()->andReturn($mockClassroom);

    // Mock the ClassRoom model directly (not using an alias, so it can be dependency injected)
    $classRoomModelMock = Mockery::mock();
    $classRoomModelMock->shouldReceive('where')->once()->with('id', $mockId)->andReturn($queryBuilderMock);

    // Mock resource (alias) agar static call intercepted
    $mockResourceResult = ['id' => 1, 'name' => 'Kelas A'];
    $classRoomResourceMock = Mockery::mock('alias:' . \App\Http\Resources\ClassRoomResource::class);
    $classRoomResourceMock->shouldReceive('make')
        ->once()
        ->with($mockClassroom)
        ->andReturn($mockResourceResult);

    $controller = new class($classRoomModelMock) {
        protected $classRoom;

        public function __construct($classRoom)
        {
            $this->classRoom = $classRoom;
        }

        public function show($id)
        {
            $classRoom = $this->classRoom->where('id', $id)->first();

            if (!$classRoom) {
                return response()->json([
                    'errors' => [
                        "message" => [
                            "not found"
                        ]
                    ]
                ], 404);
            }

            return response()->json([
                'data' => \App\Http\Resources\ClassRoomResource::make($classRoom)
            ], 200);
        }
    };

    // running the controller method
    $response = $controller->show($mockId);

    // Assert repsonse
    $this->assertInstanceOf(\Illuminate\Http\JsonResponse::class, $response);
    $this->assertEquals(200, $response->getStatusCode());
    $responseData = $response->getData(true);
    $this->assertEquals(['id' => 1, 'name' => 'Kelas A'], $responseData['data']);
}
    
Test: login is called without parameters (no parameters)
public function test_login_without_parameters_works_well()
{
    Auth::shouldReceive('check')
        ->once()
        ->andReturn(false);

    View::shouldReceive('make')
        ->with('dashboard.pages.auth.login')
        ->andReturn('login_view');

    $controller = new class {
        public function login() {
            if (Auth::check()) {
                return Redirect::to('dashboard');
            } else {
                return View::make('dashboard.pages.auth.login');
            }
        }
    };

    $result = $controller->login();

    $this->assertEquals('login_view', $result);
}

5. Use phpunit and import use Tests\\TestCase.
6. Pay attention to the use of the :: operator — it should follow the example below:
    Redirect::shouldReceive('back')->once()->andReturn($mockRedirectResponse);

    $mockRequest = Mockery::mock(LoginRequest::class);
    $mockRequest = Mockery::mock(LoginRequest::class);

    Hash::shouldReceive('check')
        ->once()
        ->with('rahasia', $userMock->password)
        ->andReturn(true);

    Untuk mock jangan menggunakan :: tetapi gunakan ->, berikut contohnya:
    $userQueryBuilderMock->shouldReceive('first')
        ->once()
        ->andReturn($userMock);

    $userModelMock->shouldReceive('where')
        ->once()
        ->with('email', 'user@gmail.com')
        ->andReturn($userQueryBuilderMock);
                        `;
                        break;
                    default:
                        vscode.window.showErrorMessage('Kode tidak termasuk function');
                        break;
                }
                break;
            case 'flutter':
                switch (type) {
                    case 'dart function':
                        prompt = `
Anda adalah seorang SOFTWARE TESTER profesional.
Tugas Anda adalah membuat kode unit test sederhana menggunakan Mockito, agar dapat dimengerti dan dijalankan oleh programmer pemula.

Tujuan 
Buat kode unit test terhadap potongan kode function di bawah ini.
${code}

${attributesModelDart ? `Attribut yang digunakan pada model yaitu sebagai berikut:\n ${attributesModelDart} \nSilakan sesuaikan data pada test dengan atribut tersebut.` : ''}
                            
ATURAN & FORMAT:
1. "Nama method harus: main"
2. "Semua test menggunakan Mockito"
3. "Seluruh pengujian dibuat dalam bentuk fungsi-fungsi public function test()"
4. "Jangan menyertakan komentar atau penjelasan — hanya kode Dart test lengkap"
5. "Tidak perlu output tambahan apapun selain kode"

CAKUPAN TEST WAJIB (minimal 4 test):
1. Test berhasil
2. Test gagal
3. Test validasi error atau exception
4. Test tanpa parameter

KETENTUAN TAMBAHAN
1. Gunakan teknik mocking penuh (Mockito) untuk semua dependency eksternal 
2. Jika terdapat pemanggilan terhadap library/helper eksternal, buat mock function-nya jika belum tersedia
3. Gunakan pattern dan struktur test seperti pada contoh di bawah ini:
4. Kode yang dibuat mengikuti contoh-contoh unit test berikut
group('ClassroomController', () {
    late MockClient mockClient;
    late ClassroomController controller;

    setUp(() {
      mockClient = MockClient();
      controller = ClassroomController(client: mockClient);
    });

    test('fetchClassrooms returns list of Classroom if status code is 200',
        () async {
      final fakeJson = jsonEncode({
        'data': [
          {
            'id': 1,
            'name': 'Kelas A',
            'code': 'KA123',
            'capacity': 30,
            'description': 'Deskripsi kelas A',
            'teacher_id': 10,
            'start_date': '2025-01-01',
            'end_date': '2025-06-30',
          },
        ]
      });

      when(mockClient.get(Uri.parse(\${URLs.baseURL}\${URLs.classrooms}')))
          .thenAnswer((_) async => http.Response(fakeJson, 200));

      final result = await controller.fetchClassrooms();

      expect(result, isA<List<Classroom>>());
      expect(result.length, 1);
      expect(result.first.name, 'Kelas A');
      expect(result.first.code, 'KA123');
      expect(result.first.description, 'Deskripsi kelas A');
      expect(result.first.teacherId, 10);
    });

    test('fetchClassrooms throws Exception if status code is not 200',
        () async {
      when(mockClient.get(Uri.parse('\${URLs.baseURL}\${URLs.classrooms}')))
          .thenAnswer((_) async => http.Response('Not found', 404));

      expect(() async => await controller.fetchClassrooms(), throwsException);
    });
  });

STRUKTUR FILE
Semua kode test harus berada dalam 1 file class berikut ini:
import 'dart:convert';

import 'package:flutter_test/flutter_test.dart';
import 'package:http/http.dart' as http;
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'package:school_app/controllers/classroom_controller.dart';
import 'package:school_app/models/classroom.dart';
import 'package:school_app/api/urls.dart';

import 'temporary_test.mocks.dart';

@GenerateMocks([http.Client])
void main() {
  group('ClassroomController', () {
    late MockClient mockClient;
    late ClassroomController controller;

    setUp(() {
      mockClient = MockClient();
      controller = ClassroomController(client: mockClient);
    });

    test('fetchClassrooms returns list of Classroom if status code is 200',
        () async {
      final fakeJson = jsonEncode({
        'data': [
          {
            'id': 1,
            'name': 'Kelas A',
            'code': 'KA123',
            'capacity': 30,
            'description': 'Deskripsi kelas A',
            'teacher_id': 10,
            'start_date': '2025-01-01',
            'end_date': '2025-06-30',
          },
        ]
      });

      when(mockClient.get(Uri.parse('\${URLs.baseURL}\${URLs.classrooms}')))
          .thenAnswer((_) async => http.Response(fakeJson, 200));

      final result = await controller.fetchClassrooms();

      expect(result, isA<List<Classroom>>());
      expect(result.length, 1);
      expect(result.first.name, 'Kelas A');
      expect(result.first.code, 'KA123');
      expect(result.first.description, 'Deskripsi kelas A');
      expect(result.first.teacherId, 10);
    });

    test('fetchClassrooms throws Exception if status code is not 200',
        () async {
      when(mockClient.get(Uri.parse('\${URLs.baseURL}\${URLs.classrooms}')))
          .thenAnswer((_) async => http.Response('Not found', 404));

      expect(() async => await controller.fetchClassrooms(), throwsException);
    });
  });
}
                        `;
                        break;

                    default:
                        vscode.window.showErrorMessage('Kode tidak termasuk function');
                        break;
                }
                break;
            default:
                vscode.window.showErrorMessage('Ekstensi tidak didukung untuk generate unit test.');
                break;
        }

        const response = await openai.chat.completions.create({
            model: 'gpt-4.1',
            messages: [
                { role: 'user', content: prompt }
            ],
            temperature: 1
        });

        const cleanResponse = GenerateTestModule.cleanResponse(response.choices[0].message.content);
        // vscode.window.showInformationMessage(`response AI ${cleanResponse}`);

        vscode.window.showInformationMessage('Sedang membuat file unit test!');
        this.temporary.createTemporaryFile({ selectedText: code, unitTestCode: cleanResponse, framework: framework });
    }

    static cleanResponse(response) {
        const match = response.match(/```(?:\w+)?\n([\s\S]*?)\n```/);
        return match ? match[1].trim() : '';
    }

}

module.exports = GenerateTestModule;
